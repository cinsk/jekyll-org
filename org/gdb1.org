# -*-org-*-
#+STARTUP: odd
#+OPTIONS: toc:4
#+STYLE: <style>body { font-family: "Helvetica Neue",Helvetica,Arial,Verdana,Geneva,sans-serif;}</style>
#+STYLE: <style>body { font-size: 90%; }</style>
#+STYLE: <style>pre.example { font-family: monospace; }</style>
#+STYLE: <style>pre { font-family: monospace; }</style>
#+LINK: google http://www.google.com/search?q=%s
#+LINK: rfc http://www.rfc-editor.org/rfc/rfc%s.txt
#+TODO: TODO(t) | DONE(d) CANCELED(c) POSTPONED
#+DRAWERS: PROPERTIES CLOCK LOGBOOK COMMENT
#+TITLE: Debugging with GDB: Breakpoints & Data Dumping
#+AUTHOR: Seong-Kook Shin
#+EMAIL: cinsky@gmail.com
#+BEGIN_HTML
---
layout: org
lang: ko
title: "Debugging with GDB: Breakpoints & Data Dumping"
---
#+END_HTML

:COMMENT:
# Markup hints:
#   *bold*, /italic/, _underlined_, =code=, ~verbatim~
#   Use '\\' at the end of a line to force a line break.
#   Use "[[URL or TARGET][NAME]]" to create a hyperlink.
#   Use "[[google:KEYWORD][DESC]]" to link to Google with KEYWORD.
#   Use "[[rfc:NUMBER][DESC]]" to link to RFC-NUMBER.txt.
#   `C-c C-o' to follow a link target.
#   Use "#+BEGIN_VERSE ... #+END_VERBSE" to format poetry
#   Use "#+BEGIN_QUOTE ... #+END_QUOTE" to format a quotation.
#   Use "#+BEGIN_CENTER ... #+END_CENTER" to center some text.
#   `C-c C-x f' for footnote action(jump or insert).
#   Unordered list items start with `-', `+', or `*' as bulllets.
#   Ordered list items start with  `1.' or `1)'.
:END:

디버깅 작업 또는 프로그램의 안전성을 검사할 때 디버거를 잘 쓰면 꽤 많은
시간을 절약할 수 있습니다.  대부분 개발자들이 GDB를 써서 디버깅을 하고
있지만, GDB가 가지고 있는 강력한 기능들을 거의 쓰지 못하고 있기
때문에, 이 글에서는 자주 쓰이지는 않을 지언정, 알면 매우 도움이 되는
기능들을 위주로 살펴보겠습니다.

먼저, 이 글을 읽는 분들이 GDB의 기본적인 사용 방법 (특히 break, run,
continue, file, backtrace, print 등)을 알고 있다고
가정하겠습니다. 기본적인 사용 방법을 모르신다면
[http://wiki.kldp.org/wiki.php/EmacsGdbEtagsCscope
Emacs/GDB/etags/cscope]나 기타 GDB manual을 참고하기 바랍니다.

* Breakpoints & Code Execution

break 명령은 대개 다음과 같이 쓸 수 있다는 것은 이미 알고 계실
것입니다:

#+BEGIN_SRC gdb
(gdb) break                # 현재 줄에 breakpoint 설정
(gdb) break 31             # 현재 파일 31번째 줄에 breakpoint 설정
(gdb) break foo            # 함수 foo에 breakpoint 설정
(gdb) break list::next     # list 클래스 next 멤버 함수에 설정
(gdb) break hello.c:main   # hello.c 파일의 main 함수에 설정
(gdb) break util.c:300     # util.c 파일의 300번째 줄에 설정
#+END_SRC

특히 C++의 경우, 한 클래스의 모든 멤버 함수에 breakpoint를 설정하고
검사할 필요가 있는데, 이 경우, 정규 표현식(regular expression)으로
breakpoint를 설정하는 rbreak 명령을 쓰면 편리합니다.  예를 들어 보면:

#+BEGIN_SRC text
(gdb) rbreak f*o           # "f*o"를 만족하는 심볼 전체에 대해 설정
(gdb) rbreak list::        # "list::.*"를 만족하는 심볼 전체에 대해 설정
#+END_SRC

특히 위 두번째 예제를 보시면 ".*"이 항상 default로 따라 온다는 것을 알
수 있습니다. 사실 rbreak 명령에 "foo"를 준 경우 사용되는 정규
표현식은, 정확히 말하면 ".*foo.*"가 됩니다. 따라서 "foo"로 시작하는
함수 전체에 대해 breakpoint를 설정하고 싶다면, 다음처럼 쓰면 됩니다:

#+BEGIN_SRC text
(gdb) rbreak ^foo
#+END_SRC

breakpoint를 설정하면, 해당 breakpoint마다 번호(BNUM)가 주어지고, 이
번호를 써서 다양한 작업을 수행할 수 있습니다. 예를 들어, 전체
breakpoint 목록을 보고 싶다면:

#+BEGIN_SRC text
 (gdb) info b
 Num Type           Disp Enb Address    What
 1   breakpoint     keep y   0x08066b44 in eventShow() at menubar.cpp:1017
         breakpoint already hit 3 time
 2   breakpoint     keep y   0x080b06f4 in Play() at thumbview.cpp:416
 3   breakpoint     keep y   0x08066e7e in ActPlay() at menubar.cpp:1085
 4   breakpoint     keep y   0x08059cd3 in Play_SS(int, int) at widgets.cpp:2183
 (gdb)
#+END_SRC

첫번째 컬럼(Num)은 각 breakpoint에 대한 고유번호(BNUM)를
나타냅니다. 그리고 두번째 컬럼(Type)은 breakpoint인지 watchpoint인지
catchpoint인지를 나타냅니다.  (watchpoint와 catchpoint는 다음에
설명..) 그리고 세번째 컬럼(Disp)은 이 breakpoint의 특징을
나타냅니다. (다음에 설명). 네번째 컬럼(Enb)는 현재 이 breakpoint가
활성화되어 있는지를 나타냅니다. 비활성화(n)로 표시된 breakpoint는
동작하지 않습니다. 활성화/비활성화는 'enable br [BNUM]' 또는 'disable
br [BNUM]'으로 변경할 수 있습니다. 예를 들어 1번 breakpoint를
비활성화하고 싶다면:

 (gdb) disable br 1

전체 breakpoint를 활성화하고 싶다면:

 (gdb) enable br

2번, 4번 breakpoint를 비활성화하고 싶다면:

 (gdb) disable br 2 4

2번부터 5번까지 breakpoint를 활성화 하고 싶다면:

 (gdb) enable br 2-5

등으로 할 수 있습니다.

때때로, 딱 한 번만 쓸 breakpoint가 필요한 경우가 있습니다. 이 경우 쓸 수 있는 명령은 enable br once [BNUM] 또는 enable br delete [BNUM]을 쓸 수 있습니다. 예를 들어 아래 명령은 1번, 3번 breakpoint를 활성화하고, 사용된 경우 바로 비활성화시킵니다:

 (gdb) enable br once 1 3

아래 명령은 4번 breakpoint를 활성화하고, 사용된 경우, 이 breakpoint를 삭제합니다:

 (gdb) enable br delete 4

쓸모있는 기능 중 하나가 바로 breakpoint에 조건을 지정하고, 해당 조건을 만족할 경우에 멈추도록 하는 것입니다. 예를 들어 다음과 같은 코드가 있다고 가정해 봅시다:

<source lang="c">
int i = 0;

/* do something #1 */

for (i = 0; i < 1000; i++) {
  /* do something #2 */
  /* do something #3 */
}
</source>

이상하게도 i가 456일때 반복문 안에서 프로그램이 이상하게 동작한다고 가정해 봅시다. 이 때 "do something #2" 부분에 breakpoint를 걸었다면 (이 breakpoint의 번호는 8번이라고 가정합시다), 반복할 때마다 계속 프로그램 실행이 멈출 겁니다. 정확히 1000번 멈추겠죠. 456번까지 진행한다는 것은 매우 귀찮은 일입니다.  이 경우, 다음과 같이 조건을 지정할 수 있습니다:

 (gdb) cond 8 i == 456

즉, 8번 breakpoint는 i == 456을 만족할 때에만 멈추도록 지정합니다. 조건식에는 단순한 상수 비교 이외에, 복잡한 함수 호출도 가능합니다. 예를 들면 다음과 같습니다:

 (gdb) cond 8 foo(i) > bar(rand())

앞에서 예로 든 코드는 단순 반복문이기 때문에, 처음 456 - 1번에 발생하는 breakpoint는 무시하라고 지정할 수도 있습니다. 처음 N번 발생하는 breakpoint를 무시하라는 명령은 다음과 같습니다:

 (gdb) ignore 8 455

즉, 8번 breakpoint는 455번 동안 무시됩니다.

또, 다음과 같은 코드를 가정해 봅시다:

<source lang="c">
int i = 0;
int j, k;
long l;

while (1) {
  j = rand();
  k = some_funtion(j, time());

  /* do something #1 */
  l = j & 0xFF00 + (int)(log(k) * 3.2108) - ...;

  if (some_condition)
    break;
}
</source>

위 코드는 j와 k가 실행할 때마다 값이 변합니다. 그리고 이상하게도 j < k 일때 변수 l이 이상한 결과를 가지는 것 같지만, 확실하지는 않습니다. 우리가 확신할 수 있는 것은 j < k일 경우, l은 항상 양수이어야 한다는 것입니다. 그래서 l의 값이 전체 반복을 끝낼 동안 어떤 값을 가지고 있는지 검사해보고 싶습니다. 이 경우 <strong>해당 breakpoint에서 멈출 때, 특정 명령을 수행하도록 하는</strong> GDB 명령인 commands를 쓰면 됩니다.

일단 "l = j &amp; 0xFF00..." 부분에 breakpoint를 걸고 (9번 breakpoint라고 가정), 다음 명령을 내립니다:

 (gdb) commands 9
 Type commands for when breakpoint 9 is hit, one per line.
 End with a line saying just "end".
 >silent
 >if j < k
  >printf "l is %d\n", l
  >end
 >cont
 >end

대충 눈치가 빠른 분은 아시겠지만 'commands [BNUM] ... end'는, BNUM breakpoint에서 멈췄을 때, "..."에 지정한 GDB 명령들을 수행합니다. 일단 silent 명령으로 명령 자체가 출력되지 않도록 한 다음, GDB printf 명령으로 변수 l 값을 출력합니다. 그리고 continue 명령으로 계속 프로그램을 진행하도록 합니다. 그 결과, 프로그램을 실행할 경우, breakpoint에서 멈추고 l 값을 출력한 다음 프로그램을 자동으로 진행합니다. 이 과정은 반복문이 끝날 때까지 계속되기 때문에, 다음과 같은 비슷한 출력을 얻을 수 있습니다.

 (gdb) continue
 l is 3
 l is -2
 l is 2
 l is 1
 l is -3

앞에서 j < k일 때, l은 항상 양수여야 한다고 말했습니다. 위 결과를 보고 우리는 l 값이 때때로 잘못된다는 것을 쉽게 알 수 있습니다.

commands에 쓸 수 있는 GDB 명령어 형태는 다음 기회에...

가끔 next나 step으로 실행 과정을 따라 가다가 반복문을 만날 경우, 반복문 끝난 부분으로 바로 건너뛰거나, 현재 함수의 실행을 정상적으로 끝내고 상위 함수로 돌아가야할 경우가 있습니다. 예를 들어:

<source lang="c">
for (i = 0; i < 1000; i++) {
  /* do something #1 */
  /* do something #2 */
}
/* do something #3 */
</source>

현재 "/* do something #2 */" 부분까지 실행했고, 이 반복문에 이상이 없다고 판단되면, 반복문 다음까지 빠르게 진행하고 싶을 겁니다. 이 경우, until 명령이나 advance 명령을 쓰면 편리합니다.

until 명령을 쓰면, 반복문이 아닌 경우에는 next 명령과 똑같이 동작합니다.

 (gdb) until

반복문일 경우, 현재 스택 프레임 (즉, 현재 함수) 안에서, 현재 줄 다음 줄에 올 때까지 프로그램을 실행합니다. 쉬운 말로, 루프를 진행하고 빠져 나오는 순간까지 실행한 다음 "(gdb)" 프롬프트를 보여줍니다.

advance 명령은 continue 명령과 마찬가지로 프로그램을 주욱 실행시키는 대신, 지정한 곳에 코드 흐름이 오면 바로 멈춥니다. 예를 들어 위 코드의 "/* do something #3 */" 부분의 줄 번호가 34였다면, until 명령 대신 다음과 같이 실행할 수도 있습니다:

 (gdb) advance 34

advance 명령은 스택 프레임에 대한 제한이 없기 때문에, 현재 함수가 아닌, 아무 곳이나 설정할 수 있으며, 위치 지정은 줄 번호 뿐만 아니라, break 명령에 쓰는 모든 형식을 다 지원합니다.


== Data Dumping ==
네트워크로 서비스 요청 데이터를 전송받아 분석하고, 적절한 기능을 수행하고, 그 결과를 돌려주는 서버 프로그램을 생각해 봅시다. 그리고 다음과 같은 꼴로 되어 있다고 가정해 봅시다:

<source lang="c">
#define PACKET_MAX      10

int
fetch(void)
{
  int packet_received = 0;
  int received[PACKET_MAX];

  while (1) {
    if (!packet_received) {
      if (recv_data(received, PACKET_MAX) == 0)
        packet_received = 1;
    }

    /* do work here */

    process_packet(received, PACKET_MAX);
  }
  return 0;
}
</source>

이 프로그램은 평소에는 정상적으로 잘 동작하지만, 특정 패킷을 받으면 이상하게 동작한다고 가정합시다. 그리고 이 패킷은 아주 가끔 들어온다고 가정해 봅시다. 원하는 대로 패킷을 보내주는 프로그램을 따로 작성해 두지 않았다면, 이 프로그램을 디버깅하기 위해서, 문제를 일으키는 패킷이 올 때까지 하염없이 기다려야할 지도 모릅니다. 실제 코드는 다음과 같습니다:

만약 원하는 패킷이 recv_data()를 통해 들어왔다고 가정합시다. 이 때 packet_received는 1이 되고, 그에 따라 처리 작업이 이상하게 동작할 것입니다. 이 때, received의 내용을 저장하기 위해, 다음 명령을 쓸 수 있습니다:

 (gdb) dump binary value buggy.dat received

위 명령을 수행하면 배열 received의 내용을 파일 buggy.dat에 저장합니다. 만약 시작 주소와 끝 주소를 알고 있다면 다음 명령을 쓸 수 있습니다:

 dump binary data buggy.dat START-ADDR END-ADDR

이 때, START-ADDR는 시작 주소를, END-ADDR는 끝 주소를 나타냅니다. 즉, 앞 received 배열의 경우, 다음과 같이 쓸 수 있습니다.

 (gdb) dump binary memory buggy.dat received received+10

어느 방법을 썼든지, 현재 디렉토리에는 buggy.dat이라는 파일로, 배열 received의 내용이 저장될 것입니다. 이는 메모리 내용을 그대로 dump시킨 것이므로 od(1)와 같은 툴을 써서 그 내용을 직접 볼 수 있습니다. received 배열은 int 배열이므로 다음과 같이 확인 가능합니다:

 $ od -td buggy.dat 
 0000000         163         151         162          85
 0000020          83         190         241         252
 0000040         249         121
 0000050
 $ _

만약, 바로 디버깅을 성공적으로 끝냈다면, 사실 위와 같은 기능은 큰 역할을 발휘하지 못합니다.  하지만, 계속해서 디버거를 실행해서 여러번 디버깅을 해야 한다면 꽤 쓸모있다는 것을 알 수 있습니다.

일단, 새로 GDB를 띄워 디버깅을 시작했다고 합시다. 

<source lang="c">
    if (!packet_received) {
</source>

위 코드를 실행할 때, 강제로 packet_received를 1로 만들어, 패킷을 받는 부분을 건너뜁니다. 변수의 값 변경은 print 명령으로 쉽게 할 수 있습니다:

 (gdb) p packet_received = 1

그리고 나서, received 배열을 아까 저장해 두었던 buggy.dat에서 다음과 같이
불러올 수 있습니다:

 (gdb) restore buggy.dat binary received
 Restoring binary file buggy.dat into memory (0xbfeda890 to 0xbfeda8b8)

이 외에도, GDB는 타 디버거에 비해 강력한 기능들을 많이 제공합니다. 다음 기회에 좀 더 알아보겠습니다.
